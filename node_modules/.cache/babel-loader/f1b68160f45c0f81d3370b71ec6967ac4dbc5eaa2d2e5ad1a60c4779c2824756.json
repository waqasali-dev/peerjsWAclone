{"ast":null,"code":"/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils.js';\nexport { shimGetUserMedia } from './getusermedia';\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => utils.filterStats(result, receiver.track, false));\n    };\n  }\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}","map":{"version":3,"names":["utils","shimGetUserMedia","shimMediaStream","window","MediaStream","webkitMediaStream","shimOnTrack","RTCPeerConnection","prototype","Object","defineProperty","get","_ontrack","set","f","removeEventListener","addEventListener","enumerable","configurable","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","e","stream","te","receiver","getReceivers","find","r","track","id","event","Event","transceiver","streams","dispatchEvent","getTracks","forEach","apply","arguments","wrapPeerConnectionEvent","value","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","undefined","kind","createDTMFSender","_pc","getSenders","_senders","slice","origAddTrack","addTrack","sender","push","origRemoveTrack","removeTrack","idx","indexOf","splice","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimSenderReceiverGetStats","RTCRtpReceiver","getStats","then","result","filterStats","origGetReceivers","receivers","srcElement","origGetStats","length","MediaStreamTrack","err","Promise","reject","DOMException","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","keys","map","streamId","alreadyExists","existingSenders","newSenders","filter","newSender","concat","shimAddTrackRemoveTrack","browserDetails","version","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","signalingState","call","t","oldStream","resolve","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","type","replaceExternalStreamId","method","nativeMethod","methodObj","args","isLegacyCall","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","isLocal","streamid","hasTrack","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","target","getConfiguration","sdpSemantics"],"sources":["C:/Users/Shogun/my-new-app/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js"],"sourcesContent":["/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n    .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n        this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n          'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n        externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n        internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n        .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n    window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n    'localDescription', {\n      get() {\n        const description = origLocalDescription.get.apply(this);\n        if (description.type === '') {\n          return description;\n        }\n        return replaceInternalStreamId(this, description);\n      }\n    });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n          'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n      .forEach(function(method) {\n        const nativeMethod = window.RTCPeerConnection.prototype[method];\n        const methodObj = {[method]() {\n          arguments[0] = new ((method === 'addIceCandidate') ?\n            window.RTCIceCandidate :\n            window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }};\n        window.RTCPeerConnection.prototype[method] = methodObj[method];\n      });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}